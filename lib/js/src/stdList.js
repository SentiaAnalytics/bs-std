// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var List     = require("bs-platform/lib/js/list.js");
var Curry    = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");

function head(xs) {
  if (xs) {
    return /* Some */[xs[0]];
  } else {
    return /* None */0;
  }
}

function tail(xs) {
  if (xs) {
    return xs[1];
  } else {
    return /* [] */0;
  }
}

function nth(_i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (xs) {
      if (i !== 0) {
        _xs = xs[1];
        _i = i - 1 | 0;
        continue ;
        
      } else {
        return /* Some */[xs[0]];
      }
    } else {
      return /* None */0;
    }
  };
}

function foldLeft2(f, _acc, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var acc = _acc;
    if (xs) {
      if (ys) {
        _ys = ys[1];
        _xs = xs[1];
        _acc = Curry._3(f, acc, xs[0], ys[0]);
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

function foldRight2(f, l1, l2, acc) {
  if (l1 && l2) {
    return Curry._3(f, l1[0], l2[0], foldRight2(f, l1[1], l2[1], acc));
  } else {
    return acc;
  }
}

function iter2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    if (xs) {
      if (ys) {
        Curry._2(f, xs[0], ys[0]);
        _ys = ys[1];
        _xs = xs[1];
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function map2(f, xs, ys) {
  if (xs && ys) {
    return /* :: */[
            Curry._2(f, xs[0], ys[0]),
            map2(f, xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function reverseMap2(f, xs, ys) {
  var _acc = /* [] */0;
  var f$1 = f;
  var _xs = xs;
  var _ys = ys;
  while(true) {
    var ys$1 = _ys;
    var xs$1 = _xs;
    var acc = _acc;
    if (xs$1) {
      if (ys$1) {
        _ys = ys$1[1];
        _xs = xs$1[1];
        _acc = /* :: */[
          Curry._2(f$1, xs$1[0], ys$1[0]),
          acc
        ];
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

function forAll2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    if (xs) {
      if (ys) {
        if (Curry._2(f, xs[0], ys[0])) {
          _ys = ys[1];
          _xs = xs[1];
          continue ;
          
        } else {
          return /* false */0;
        }
      } else {
        return /* true */1;
      }
    } else {
      return /* true */1;
    }
  };
}

function exists2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    if (xs) {
      if (ys) {
        if (Curry._2(f, xs[0], ys[0])) {
          return /* true */1;
        } else {
          _ys = ys[1];
          _xs = xs[1];
          continue ;
          
        }
      } else {
        return /* false */0;
      }
    } else {
      return /* false */0;
    }
  };
}

function find(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var x = xs[0];
      if (Curry._1(f, x)) {
        return /* Some */[x];
      } else {
        _xs = xs[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function assoc(key, _pairs) {
  while(true) {
    var pairs = _pairs;
    if (pairs) {
      var match = pairs[0];
      if (Caml_obj.caml_equal(match[0], key)) {
        return /* Some */[match[1]];
      } else {
        _pairs = pairs[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function zip(xs, ys) {
  if (xs && ys) {
    return /* :: */[
            /* tuple */[
              xs[0],
              ys[0]
            ],
            zip(xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

var length = List.length;

var reverse = List.rev;

var append = List.append;

var reverseAppend = List.rev_append;

var concat = List.concat;

var flatten = List.flatten;

var iter = List.iter;

var iteri = List.iteri;

var map = List.map;

var mapi = List.mapi;

var reverseMap = List.rev_map;

var foldLeft = List.fold_left;

var foldRight = List.fold_right;

var forAll = List.for_all;

var exists = List.exists;

var contains = List.mem;

var filter = List.filter;

var partition = List.partition;

var containsAssoc = List.mem_assoc;

var removeAssoc = List.remove_assoc;

var split = List.split;

var sort = List.sort;

var stableSort = List.stable_sort;

var fastSort = List.fast_sort;

var sortUniq = List.sort_uniq;

var merge = List.merge;

exports.length        = length;
exports.head          = head;
exports.tail          = tail;
exports.nth           = nth;
exports.reverse       = reverse;
exports.append        = append;
exports.reverseAppend = reverseAppend;
exports.concat        = concat;
exports.flatten       = flatten;
exports.iter          = iter;
exports.iteri         = iteri;
exports.map           = map;
exports.mapi          = mapi;
exports.reverseMap    = reverseMap;
exports.foldLeft      = foldLeft;
exports.foldRight     = foldRight;
exports.iter2         = iter2;
exports.map2          = map2;
exports.reverseMap2   = reverseMap2;
exports.foldLeft2     = foldLeft2;
exports.foldRight2    = foldRight2;
exports.forAll        = forAll;
exports.exists        = exists;
exports.forAll2       = forAll2;
exports.exists2       = exists2;
exports.contains      = contains;
exports.find          = find;
exports.filter        = filter;
exports.partition     = partition;
exports.assoc         = assoc;
exports.containsAssoc = containsAssoc;
exports.removeAssoc   = removeAssoc;
exports.split         = split;
exports.zip           = zip;
exports.sort          = sort;
exports.stableSort    = stableSort;
exports.fastSort      = fastSort;
exports.sortUniq      = sortUniq;
exports.merge         = merge;
/* No side effect */
