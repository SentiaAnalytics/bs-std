// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var List       = require("bs-platform/lib/js/list.js");
var Curry      = require("bs-platform/lib/js/curry.js");
var Caml_obj   = require("bs-platform/lib/js/caml_obj.js");
var StdOption  = require("./stdOption.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");

function reverse(xs) {
  var _acc = /* [] */0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var acc = _acc;
    if (xs$1) {
      _xs = xs$1[1];
      _acc = /* :: */[
        xs$1[0],
        acc
      ];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function isEmpty(xs) {
  if (xs) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function foldLeft(f, _acc, _xs) {
  while(true) {
    var xs = _xs;
    var acc = _acc;
    if (xs) {
      _xs = xs[1];
      _acc = Curry._2(f, acc, xs[0]);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function foldRight(f, acc, xs) {
  if (xs) {
    return Curry._2(f, xs[0], foldRight(f, acc, xs[1]));
  } else {
    return acc;
  }
}

function foldLeft2(f, _acc, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var acc = _acc;
    if (xs) {
      if (ys) {
        _ys = ys[1];
        _xs = xs[1];
        _acc = Curry._3(f, acc, xs[0], ys[0]);
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

function foldRight2(f, acc, xs, ys) {
  if (xs && ys) {
    return Curry._3(f, xs[0], ys[0], foldRight2(f, acc, xs[1], ys[1]));
  } else {
    return acc;
  }
}

function repeat(count, x) {
  var _acc = /* [] */0;
  var _count = count;
  while(true) {
    var count$1 = _count;
    var acc = _acc;
    if (count$1 <= 0) {
      return acc;
    } else {
      _count = count$1 - 1 | 0;
      _acc = /* :: */[
        x,
        acc
      ];
      continue ;
      
    }
  };
}

function range(start, stop) {
  var go = function (acc, start) {
    if (start >= stop) {
      return acc;
    } else {
      return /* :: */[
              start,
              go(acc, start + 1 | 0)
            ];
    }
  };
  return go(/* [] */0, start);
}

function append(x, xs) {
  return Pervasives.$at(xs, /* :: */[
              x,
              /* [] */0
            ]);
}

var concat = Pervasives.$at;

function flatten(xs) {
  return foldLeft(concat, /* [] */0, xs);
}

function zip(xs, ys) {
  if (xs && ys) {
    return /* :: */[
            /* tuple */[
              xs[0],
              ys[0]
            ],
            zip(xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function head(xs) {
  if (xs) {
    return /* Some */[xs[0]];
  } else {
    return /* None */0;
  }
}

function tail(xs) {
  if (xs) {
    return xs[1];
  } else {
    return /* [] */0;
  }
}

function nth(_i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (xs) {
      if (i <= 0) {
        return /* Some */[xs[0]];
      } else {
        _xs = xs[1];
        _i = i - 1 | 0;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function take(count, xs) {
  if (xs && count > 0) {
    return /* :: */[
            xs[0],
            take(count - 1 | 0, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function drop(_count, _xs) {
  while(true) {
    var xs = _xs;
    var count = _count;
    if (xs) {
      if (count <= 0) {
        return /* [] */0;
      } else {
        _xs = xs[1];
        _count = count - 1 | 0;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function takeLast(count, xs) {
  return drop(List.length(xs) - count | 0, xs);
}

function takeUntil(f, xs) {
  var _acc = /* [] */0;
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var acc = _acc;
    if (xs$1) {
      var x = xs$1[0];
      if (Curry._1(f$1, x)) {
        return acc;
      } else {
        _xs = xs$1[1];
        _acc = /* :: */[
          x,
          acc
        ];
        continue ;
        
      }
    } else {
      return acc;
    }
  };
}

function takeWhile(f, xs) {
  return takeUntil((function (a) {
                return 1 - Curry._1(f, a);
              }), xs);
}

function dropLast(count, xs) {
  return take(List.length(xs) - count | 0, xs);
}

function dropUntil(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      if (Curry._1(f, xs[0])) {
        return xs;
      } else {
        _xs = xs[1];
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function dropWhile(f, xs) {
  return dropUntil((function (x) {
                return 1 - Curry._1(f, x);
              }), xs);
}

function filter(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var xs$1 = xs[1];
      var x = xs[0];
      if (Curry._1(f, x)) {
        return /* :: */[
                x,
                filter(f, xs$1)
              ];
      } else {
        _xs = xs$1;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function map(f, xs) {
  if (xs) {
    return /* :: */[
            Curry._1(f, xs[0]),
            map(f, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapIndexed(f, xs) {
  var go = function (i, f, xs) {
    if (xs) {
      return /* :: */[
              Curry._2(f, i, xs[0]),
              go(i + 1 | 0, f, xs[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return go(0, f, xs);
}

function map2(f, xs, ys) {
  if (xs && ys) {
    return /* :: */[
            Curry._2(f, xs[0], ys[0]),
            map2(f, xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function flatMap(f, xs) {
  if (xs) {
    return Pervasives.$at(Curry._1(f, xs[0]), flatMap(f, xs[1]));
  } else {
    return /* [] */0;
  }
}

function flatMap2(f, xs, ys) {
  if (xs && ys) {
    return Pervasives.$at(Curry._2(f, xs[0], ys[0]), flatMap2(f, xs[1], ys[1]));
  } else {
    return /* [] */0;
  }
}

function iter(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      Curry._1(f, xs[0]);
      _xs = xs[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iter2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    if (xs) {
      if (ys) {
        Curry._2(f, xs[0], ys[0]);
        _ys = ys[1];
        _xs = xs[1];
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function iterIndexed(f, xs) {
  var _i = 0;
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var i = _i;
    if (xs$1) {
      Curry._2(f$1, i, xs$1[0]);
      _xs = xs$1[1];
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function find(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var x = xs[0];
      if (Curry._1(f, x)) {
        return /* Some */[x];
      } else {
        _xs = xs[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function any(f, xs) {
  return StdOption.isSome(find(f, xs));
}

function all(f, xs) {
  return StdOption.isSome(find((function (x) {
                    return 1 - Curry._1(f, x);
                  }), xs));
}

function contains(y, xs) {
  return StdOption.isSome(find((function (x) {
                    return Caml_obj.caml_equal(x, y);
                  }), xs));
}

function partition(f, xs) {
  var _param = /* tuple */[
    /* [] */0,
    /* [] */0
  ];
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var param = _param;
    var xs$1 = _xs;
    var l2 = param[1];
    var l1 = param[0];
    if (xs$1) {
      var xs$2 = xs$1[1];
      var x = xs$1[0];
      if (Curry._1(f$1, x)) {
        _xs = xs$2;
        _param = /* tuple */[
          /* :: */[
            x,
            l1
          ],
          l2
        ];
        continue ;
        
      } else {
        _xs = xs$2;
        _param = /* tuple */[
          l1,
          /* :: */[
            x,
            l2
          ]
        ];
        continue ;
        
      }
    } else {
      return /* tuple */[
              l1,
              l2
            ];
    }
  };
}

function split(pairs) {
  var _param = /* tuple */[
    /* [] */0,
    /* [] */0
  ];
  var _pairs = pairs;
  while(true) {
    var param = _param;
    var pairs$1 = _pairs;
    var ys = param[1];
    var xs = param[0];
    if (pairs$1) {
      var match = pairs$1[0];
      _pairs = pairs$1[1];
      _param = /* tuple */[
        /* :: */[
          match[0],
          xs
        ],
        /* :: */[
          match[1],
          ys
        ]
      ];
      continue ;
      
    } else {
      return /* tuple */[
              xs,
              ys
            ];
    }
  };
}

var length = List.length;

var merge = List.merge;

var sort = List.sort;

exports.length      = length;
exports.isEmpty     = isEmpty;
exports.reverse     = reverse;
exports.merge       = merge;
exports.repeat      = repeat;
exports.range       = range;
exports.append      = append;
exports.concat      = concat;
exports.flatten     = flatten;
exports.zip         = zip;
exports.head        = head;
exports.tail        = tail;
exports.nth         = nth;
exports.take        = take;
exports.takeLast    = takeLast;
exports.takeWhile   = takeWhile;
exports.takeUntil   = takeUntil;
exports.drop        = drop;
exports.dropLast    = dropLast;
exports.dropWhile   = dropWhile;
exports.dropUntil   = dropUntil;
exports.filter      = filter;
exports.map         = map;
exports.mapIndexed  = mapIndexed;
exports.map2        = map2;
exports.flatMap     = flatMap;
exports.flatMap2    = flatMap2;
exports.iter        = iter;
exports.iter2       = iter2;
exports.iterIndexed = iterIndexed;
exports.foldLeft    = foldLeft;
exports.foldRight   = foldRight;
exports.foldLeft2   = foldLeft2;
exports.foldRight2  = foldRight2;
exports.find        = find;
exports.all         = all;
exports.any         = any;
exports.contains    = contains;
exports.partition   = partition;
exports.split       = split;
exports.sort        = sort;
/* No side effect */
