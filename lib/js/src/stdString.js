// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var Curry                   = require("bs-platform/lib/js/curry.js");
var Js_exn                  = require("bs-platform/lib/js/js_exn.js");
var $$String                = require("bs-platform/lib/js/string.js");
var StdList                 = require("./stdList.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function length(prim) {
  return prim.length;
}

function isEmpty(s) {
  return +(s === "");
}

function fromChar(param) {
  return $$String.make(1, param);
}

function fromChars(chars) {
  return StdList.foldLeft((function (str, ch) {
                return str + fromChar(ch);
              }), "", chars);
}

function get(index, str) {
  try {
    return /* Some */[Caml_string.get(str, index)];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function cons(ch, str) {
  return $$String.make(1, ch) + str;
}

function substring(start, len, str) {
  try {
    return $$String.sub(str, start, Pervasives.min(len, str.length - start | 0));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return "";
    } else {
      throw exn;
    }
  }
}

function uncons(str) {
  var match = get(0, str);
  if (match) {
    return /* Some */[/* tuple */[
              match[0],
              substring(1, str.length, str)
            ]];
  } else {
    return /* None */0;
  }
}

function take(i, str) {
  return substring(0, i, str);
}

function drop(i, str) {
  return substring(i, str.length, str);
}

function takeLast(i, str) {
  return drop(str.length - i | 0, str);
}

function dropLast(i, str) {
  return substring(0, str.length - i | 0, str);
}

function takeUntil(f, str) {
  var match = uncons(str);
  if (match) {
    var match$1 = match[0];
    var ch = match$1[0];
    if (Curry._1(f, ch)) {
      return "";
    } else {
      return fromChar(ch) + takeUntil(f, match$1[1]);
    }
  } else {
    return "";
  }
}

function takeWhile(f, str) {
  return takeUntil((function (x) {
                return 1 - Curry._1(f, x);
              }), str);
}

function dropUntil(f, _str) {
  while(true) {
    var str = _str;
    var match = uncons(str);
    if (match) {
      var match$1 = match[0];
      var str$1 = match$1[1];
      if (Curry._1(f, match$1[0])) {
        return str$1;
      } else {
        _str = str$1;
        continue ;
        
      }
    } else {
      return "";
    }
  };
}

function dropWhile(f, str) {
  return dropUntil((function (x) {
                return 1 - Curry._1(f, x);
              }), str);
}

function reverse(s) {
  var match = uncons(s);
  if (match) {
    var match$1 = match[0];
    return reverse(match$1[1]) + fromChar(match$1[0]);
  } else {
    return "";
  }
}

function concat(x, y) {
  return x + y;
}

function indexOf(ch, str) {
  try {
    return /* Some */[$$String.index(str, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function lastIndexOf(ch, str) {
  try {
    return /* Some */[$$String.rindex(str, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function indexFrom(i, ch, str) {
  try {
    return /* Some */[$$String.index_from(str, i, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function lastIndexFrom(i, ch, str) {
  try {
    return /* Some */[$$String.rindex_from(str, i, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function contains(c, s) {
  return $$String.contains(s, c);
}

function pad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = padding + (str + padding);
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function leftPad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = padding + str;
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function rightPad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = str + padding;
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function split(separator, str) {
  var len = separator.length;
  var go = function (_i, str) {
    while(true) {
      var i = _i;
      var sub = substring(i, len, str);
      if (sub === separator) {
        return /* :: */[
                substring(0, i, str),
                go(0, drop(i + len | 0, str))
              ];
      } else if (i === str.length) {
        return /* :: */[
                str,
                /* [] */0
              ];
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    };
  };
  return go(0, str);
}

function lines(param) {
  return split("\n", param);
}

function words(param) {
  return split(" ", param);
}

var fromInt = Pervasives.string_of_int;

var fromFloat = Pervasives.string_of_float;

var escaped = $$String.escaped;

var uppercase = $$String.uppercase;

var lowercase = $$String.lowercase;

var capitalize = $$String.capitalize;

var uncapitalize = $$String.uncapitalize;

var trim = $$String.trim;

var join = $$String.concat;

var iter = $$String.iter;

var iterIndexed = $$String.iteri;

var map = $$String.map;

var mapIndexed = $$String.mapi;

exports.length        = length;
exports.isEmpty       = isEmpty;
exports.fromChar      = fromChar;
exports.fromInt       = fromInt;
exports.fromFloat     = fromFloat;
exports.fromChars     = fromChars;
exports.escaped       = escaped;
exports.reverse       = reverse;
exports.uppercase     = uppercase;
exports.lowercase     = lowercase;
exports.capitalize    = capitalize;
exports.uncapitalize  = uncapitalize;
exports.get           = get;
exports.substring     = substring;
exports.trim          = trim;
exports.take          = take;
exports.drop          = drop;
exports.takeLast      = takeLast;
exports.dropLast      = dropLast;
exports.takeUntil     = takeUntil;
exports.takeWhile     = takeWhile;
exports.dropUntil     = dropUntil;
exports.dropWhile     = dropWhile;
exports.split         = split;
exports.words         = words;
exports.lines         = lines;
exports.cons          = cons;
exports.uncons        = uncons;
exports.concat        = concat;
exports.join          = join;
exports.pad           = pad;
exports.leftPad       = leftPad;
exports.rightPad      = rightPad;
exports.iter          = iter;
exports.iterIndexed   = iterIndexed;
exports.map           = map;
exports.mapIndexed    = mapIndexed;
exports.indexOf       = indexOf;
exports.lastIndexOf   = lastIndexOf;
exports.indexFrom     = indexFrom;
exports.lastIndexFrom = lastIndexFrom;
exports.contains      = contains;
/* No side effect */
