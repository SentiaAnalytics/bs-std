// Generated by BUCKLESCRIPT VERSION 1.9.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Js_exn                  = require("bs-platform/lib/js/js_exn.js");
var Option                  = require("./option.js");
var Remote                  = require("./remote.js");
var Result                  = require("./result.js");
var $$String                = require("bs-platform/lib/js/string.js");
var Js_dict                 = require("bs-platform/lib/js/js_dict.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Json_decode             = require("bs-json/lib/js/src/json_decode.js");
var Json_encode             = require("bs-json/lib/js/src/json_encode.js");
var Js_primitive            = require("bs-platform/lib/js/js_primitive.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function identity(a) {
  return a;
}

function always(a, _) {
  return a;
}

function $$void() {
  return /* () */0;
}

function $great$great(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function flip(f, a, b) {
  return Curry._2(f, b, a);
}

function curry(f, a, b) {
  return Curry._1(f, /* tuple */[
              a,
              b
            ]);
}

function uncurry(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function tap(f, a) {
  Curry._1(f, a);
  return a;
}

var Option$1 = /* module */[
  /* some */Option.some,
  /* none */Option.none,
  /* map */Option.map,
  /* map2 */Option.map2,
  /* map3 */Option.map3,
  /* flatten */Option.flatten,
  /* flatMap */Option.flatMap,
  /* withDefault */Option.withDefault,
  /* fromResult */Option.fromResult,
  /* fromRemote */Option.fromRemote,
  /* isNone */Option.isNone,
  /* isSome */Option.isSome,
  /* encode */Option.encode,
  /* decode */Option.decode
];

var Result$1 = /* module */[
  /* map */Result.map,
  /* map2 */Result.map2,
  /* map3 */Result.map3,
  /* flatten */Result.flatten,
  /* flatMap */Result.flatMap,
  /* withDefault */Result.withDefault,
  /* fromOption */Result.fromOption,
  /* isError */Result.isError,
  /* isOk */Result.isOk,
  /* encode */Result.encode
];

function reverse(xs) {
  var _acc = /* [] */0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var acc = _acc;
    if (xs$1) {
      _xs = xs$1[1];
      _acc = /* :: */[
        xs$1[0],
        acc
      ];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function isEmpty(xs) {
  if (xs) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function foldLeft(f, _acc, _xs) {
  while(true) {
    var xs = _xs;
    var acc = _acc;
    if (xs) {
      _xs = xs[1];
      _acc = Curry._2(f, xs[0], acc);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function foldRight(f, acc, xs) {
  if (xs) {
    return Curry._2(f, xs[0], foldRight(f, acc, xs[1]));
  } else {
    return acc;
  }
}

function foldLeft2(f, _acc, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var acc = _acc;
    if (xs) {
      if (ys) {
        _ys = ys[1];
        _xs = xs[1];
        _acc = Curry._3(f, xs[0], ys[0], acc);
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

function foldRight2(f, acc, xs, ys) {
  if (xs && ys) {
    return Curry._3(f, xs[0], ys[0], foldRight2(f, acc, xs[1], ys[1]));
  } else {
    return acc;
  }
}

function repeat(count, x) {
  var _acc = /* [] */0;
  var _count = count;
  while(true) {
    var count$1 = _count;
    var acc = _acc;
    if (count$1 <= 0) {
      return acc;
    } else {
      _count = count$1 - 1 | 0;
      _acc = /* :: */[
        x,
        acc
      ];
      continue ;
      
    }
  };
}

function range(start, stop) {
  var go = function (acc, start) {
    if (start >= stop) {
      return acc;
    } else {
      return /* :: */[
              start,
              go(acc, start + 1 | 0)
            ];
    }
  };
  return go(/* [] */0, start);
}

function cons(x, xs) {
  return Pervasives.$at(xs, /* :: */[
              x,
              /* [] */0
            ]);
}

var append = Pervasives.$at;

function flatten(xs) {
  return foldLeft(append, /* [] */0, xs);
}

function zip(xs, ys) {
  if (xs && ys) {
    return /* :: */[
            /* tuple */[
              xs[0],
              ys[0]
            ],
            zip(xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function head(xs) {
  if (xs) {
    return /* Some */[xs[0]];
  } else {
    return /* None */0;
  }
}

function tail(xs) {
  if (xs) {
    return xs[1];
  } else {
    return /* [] */0;
  }
}

function nth(_i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (xs) {
      if (i <= 0) {
        return /* Some */[xs[0]];
      } else {
        _xs = xs[1];
        _i = i - 1 | 0;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function take(count, xs) {
  if (xs && count > 0) {
    return /* :: */[
            xs[0],
            take(count - 1 | 0, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function drop(_count, _xs) {
  while(true) {
    var xs = _xs;
    var count = _count;
    if (xs) {
      if (count <= 0) {
        return /* [] */0;
      } else {
        _xs = xs[1];
        _count = count - 1 | 0;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function takeLast(count, xs) {
  return drop(List.length(xs) - count | 0, xs);
}

function takeUntil(f, xs) {
  var _acc = /* [] */0;
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var acc = _acc;
    if (xs$1) {
      var x = xs$1[0];
      if (Curry._1(f$1, x)) {
        return acc;
      } else {
        _xs = xs$1[1];
        _acc = /* :: */[
          x,
          acc
        ];
        continue ;
        
      }
    } else {
      return acc;
    }
  };
}

function takeWhile(f, xs) {
  return takeUntil((function (a) {
                return 1 - Curry._1(f, a);
              }), xs);
}

function dropLast(count, xs) {
  return take(List.length(xs) - count | 0, xs);
}

function dropUntil(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      if (Curry._1(f, xs[0])) {
        return xs;
      } else {
        _xs = xs[1];
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function dropWhile(f, xs) {
  return dropUntil((function (x) {
                return 1 - Curry._1(f, x);
              }), xs);
}

function filter(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var xs$1 = xs[1];
      var x = xs[0];
      if (Curry._1(f, x)) {
        return /* :: */[
                x,
                filter(f, xs$1)
              ];
      } else {
        _xs = xs$1;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function map(f, xs) {
  if (xs) {
    return /* :: */[
            Curry._1(f, xs[0]),
            map(f, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapIndexed(f, xs) {
  var go = function (i, f, xs) {
    if (xs) {
      return /* :: */[
              Curry._2(f, i, xs[0]),
              go(i + 1 | 0, f, xs[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return go(0, f, xs);
}

function map2(f, xs, ys) {
  if (xs && ys) {
    return /* :: */[
            Curry._2(f, xs[0], ys[0]),
            map2(f, xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function flatMap(f, xs) {
  if (xs) {
    return Pervasives.$at(Curry._1(f, xs[0]), flatMap(f, xs[1]));
  } else {
    return /* [] */0;
  }
}

function flatMap2(f, xs, ys) {
  if (xs && ys) {
    return Pervasives.$at(Curry._2(f, xs[0], ys[0]), flatMap2(f, xs[1], ys[1]));
  } else {
    return /* [] */0;
  }
}

function filterMap(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var xs$1 = xs[1];
      var match = Curry._1(f, xs[0]);
      if (match) {
        return /* :: */[
                match[0],
                filterMap(f, xs$1)
              ];
      } else {
        _xs = xs$1;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function iter(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      Curry._1(f, xs[0]);
      _xs = xs[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iter2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    if (xs) {
      if (ys) {
        Curry._2(f, xs[0], ys[0]);
        _ys = ys[1];
        _xs = xs[1];
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function iterIndexed(f, xs) {
  var _i = 0;
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var i = _i;
    if (xs$1) {
      Curry._2(f$1, i, xs$1[0]);
      _xs = xs$1[1];
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function find(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var x = xs[0];
      if (Curry._1(f, x)) {
        return /* Some */[x];
      } else {
        _xs = xs[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function any(f, xs) {
  return Option.isSome(find(f, xs));
}

function all(f, xs) {
  return any((function (x) {
                return 1 - Curry._1(f, x);
              }), xs);
}

function contains(y, xs) {
  return any((function (x) {
                return Caml_obj.caml_equal(x, y);
              }), xs);
}

function partition(f, xs) {
  var _param = /* tuple */[
    /* [] */0,
    /* [] */0
  ];
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var param = _param;
    var xs$1 = _xs;
    var l2 = param[1];
    var l1 = param[0];
    if (xs$1) {
      var xs$2 = xs$1[1];
      var x = xs$1[0];
      if (Curry._1(f$1, x)) {
        _xs = xs$2;
        _param = /* tuple */[
          /* :: */[
            x,
            l1
          ],
          l2
        ];
        continue ;
        
      } else {
        _xs = xs$2;
        _param = /* tuple */[
          l1,
          /* :: */[
            x,
            l2
          ]
        ];
        continue ;
        
      }
    } else {
      return /* tuple */[
              l1,
              l2
            ];
    }
  };
}

function split(pairs) {
  var _param = /* tuple */[
    /* [] */0,
    /* [] */0
  ];
  var _pairs = pairs;
  while(true) {
    var param = _param;
    var pairs$1 = _pairs;
    var ys = param[1];
    var xs = param[0];
    if (pairs$1) {
      var match = pairs$1[0];
      _pairs = pairs$1[1];
      _param = /* tuple */[
        /* :: */[
          match[0],
          xs
        ],
        /* :: */[
          match[1],
          ys
        ]
      ];
      continue ;
      
    } else {
      return /* tuple */[
              xs,
              ys
            ];
    }
  };
}

function fromList(a) {
  return a;
}

function get(key, _dict) {
  while(true) {
    var dict = _dict;
    if (dict) {
      var match = dict[0];
      if (Caml_obj.caml_equal(match[0], key)) {
        return /* Some */[match[1]];
      } else {
        _dict = dict[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function find$1(f, _dict) {
  while(true) {
    var dict = _dict;
    if (dict) {
      var v = dict[0][1];
      if (Curry._1(f, v)) {
        return /* Some */[v];
      } else {
        _dict = dict[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function contains$1(key, dict) {
  return Option.isSome(get(key, dict));
}

function set(key, value, dict) {
  return /* :: */[
          /* tuple */[
            key,
            value
          ],
          filter((function (param) {
                  return Caml_obj.caml_notequal(param[0], key);
                }), dict)
        ];
}

function setDefault(key, value, dict) {
  if (contains$1(key, dict)) {
    return dict;
  } else {
    return /* :: */[
            /* tuple */[
              key,
              value
            ],
            dict
          ];
  }
}

function keys(dict) {
  return map((function (param) {
                return param[0];
              }), dict);
}

function values(dict) {
  return map((function (param) {
                return param[1];
              }), dict);
}

function iter$1(f) {
  return (function (param) {
      return iter((function (param) {
                    return uncurry(f, param);
                  }), param);
    });
}

function map$1(f, dict) {
  return map((function (param) {
                var k = param[0];
                return /* tuple */[
                        k,
                        Curry._2(f, k, param[1])
                      ];
              }), dict);
}

function mapValues(f, dict) {
  return map((function (param) {
                return /* tuple */[
                        param[0],
                        Curry._1(f, param[1])
                      ];
              }), dict);
}

function mapKeys(f, dict) {
  return map((function (param) {
                return /* tuple */[
                        Curry._1(f, param[0]),
                        param[1]
                      ];
              }), dict);
}

function filter$1(f) {
  return (function (param) {
      return filter((function (param) {
                    return uncurry(f, param);
                  }), param);
    });
}

function foldLeft$1(f, acc, dict) {
  return foldLeft((function (param, acc) {
                return Curry._3(f, param[0], param[1], acc);
              }), acc, dict);
}

function foldRight$1(f, acc, dict) {
  return foldRight((function (param, acc) {
                return Curry._3(f, param[0], param[1], acc);
              }), acc, dict);
}

function encode(encodeKey, encodeValue, dict) {
  return Json_encode.object_(mapValues(encodeValue, mapKeys(encodeKey, dict)));
}

function decode(decodeKey, decodeValue, json) {
  return mapKeys(decodeKey, $$Array.to_list(Js_dict.entries(Json_decode.dict(decodeValue, json))));
}

var Dict = /* module */[
  /* empty : [] */0,
  /* fromList */fromList,
  /* get */get,
  /* find */find$1,
  /* contains */contains$1,
  /* set */set,
  /* setDefault */setDefault,
  /* keys */keys,
  /* values */values,
  /* iter */iter$1,
  /* map */map$1,
  /* mapValues */mapValues,
  /* mapKeys */mapKeys,
  /* filter */filter$1,
  /* foldLeft */foldLeft$1,
  /* foldRight */foldRight$1,
  /* encode */encode,
  /* decode */decode
];

function length(prim) {
  return prim.length;
}

function isEmpty$1(s) {
  return +(s === "");
}

function fromChar(param) {
  return $$String.make(1, param);
}

function fromChars(chars) {
  return foldLeft((function (ch, str) {
                return str + $$String.make(1, ch);
              }), "", chars);
}

function get$1(index, str) {
  try {
    return /* Some */[Caml_string.get(str, index)];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function cons$1(ch, str) {
  return $$String.make(1, ch) + str;
}

function substring(start, len, str) {
  try {
    return $$String.sub(str, start, Pervasives.min(len, str.length - start | 0));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return "";
    } else {
      throw exn;
    }
  }
}

function uncons(str) {
  var match = get$1(0, str);
  if (match) {
    return /* Some */[/* tuple */[
              match[0],
              substring(1, str.length, str)
            ]];
  } else {
    return /* None */0;
  }
}

function take$1(i, str) {
  return substring(0, i, str);
}

function drop$1(i, str) {
  return substring(i, str.length, str);
}

function takeLast$1(i, str) {
  return drop$1(str.length - i | 0, str);
}

function dropLast$1(i, str) {
  return substring(0, str.length - i | 0, str);
}

function takeUntil$1(f, str) {
  var match = uncons(str);
  if (match) {
    var match$1 = match[0];
    var ch = match$1[0];
    if (Curry._1(f, ch)) {
      return "";
    } else {
      return $$String.make(1, ch) + takeUntil$1(f, match$1[1]);
    }
  } else {
    return "";
  }
}

function takeWhile$1(f, str) {
  return takeUntil$1((function (x) {
                return 1 - Curry._1(f, x);
              }), str);
}

function dropUntil$1(f, _str) {
  while(true) {
    var str = _str;
    var match = uncons(str);
    if (match) {
      var match$1 = match[0];
      var str$1 = match$1[1];
      if (Curry._1(f, match$1[0])) {
        return str$1;
      } else {
        _str = str$1;
        continue ;
        
      }
    } else {
      return "";
    }
  };
}

function dropWhile$1(f, str) {
  return dropUntil$1((function (x) {
                return 1 - Curry._1(f, x);
              }), str);
}

function reverse$1(s) {
  var match = uncons(s);
  if (match) {
    var match$1 = match[0];
    return reverse$1(match$1[1]) + $$String.make(1, match$1[0]);
  } else {
    return "";
  }
}

function append$1(x, y) {
  return x + y;
}

function indexOf(ch, str) {
  try {
    return /* Some */[$$String.index(str, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function lastIndexOf(ch, str) {
  try {
    return /* Some */[$$String.rindex(str, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function indexFrom(i, ch, str) {
  try {
    return /* Some */[$$String.index_from(str, i, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function lastIndexFrom(i, ch, str) {
  try {
    return /* Some */[$$String.rindex_from(str, i, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function contains$2(c, s) {
  return $$String.contains(s, c);
}

function pad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = padding + (str + padding);
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function leftPad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = padding + str;
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function rightPad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = str + padding;
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function split$1(separator, str) {
  var len = separator.length;
  var go = function (_i, str) {
    while(true) {
      var i = _i;
      var sub = substring(i, len, str);
      if (sub === separator) {
        return /* :: */[
                substring(0, i, str),
                go(0, drop$1(i + len | 0, str))
              ];
      } else if (i === str.length) {
        return /* :: */[
                str,
                /* [] */0
              ];
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    };
  };
  return go(0, str);
}

function lines(param) {
  return split$1("\n", param);
}

function words(param) {
  return split$1(" ", param);
}

function encode$1(prim) {
  return prim;
}

function make(create, fail, success) {
  return Curry._2(create, fail, success);
}

function succeed(a) {
  return (function (_, param) {
      return Curry._1(param, a);
    });
}

function fail(x) {
  return (function (param, _) {
      return Curry._1(param, x);
    });
}

function fork(fail, success, task) {
  return Curry._2(task, fail, success);
}

function map$2(f, task) {
  return (function (param, param$1) {
      return Curry._2(task, param, (function (x) {
                    return Curry._1(param$1, Curry._1(f, x));
                  }));
    });
}

function map2$1(f, t1, t2) {
  return (function (param, param$1) {
      return Curry._2(t1, param, (function (a1) {
                    return Curry._2(t2, param, (function (a2) {
                                  return Curry._1(param$1, Curry._2(f, a1, a2));
                                }));
                  }));
    });
}

function map3(f, t1, t2, t3) {
  return (function (param, param$1) {
      return Curry._2(t1, param, (function (a1) {
                    return Curry._2(t2, param, (function (a2) {
                                  return Curry._2(t3, param, (function (a3) {
                                                return Curry._1(param$1, Curry._3(f, a1, a2, a3));
                                              }));
                                }));
                  }));
    });
}

function flatMap$1(f, task) {
  return (function (param, param$1) {
      return Curry._2(task, param, (function (x) {
                    return Curry._3(f, x, param, param$1);
                  }));
    });
}

function biMap(mapFail, mapSuccess, task) {
  return (function (param, param$1) {
      return Curry._2(task, (function (err) {
                    return Curry._1(param, Curry._1(mapFail, err));
                  }), (function (ok) {
                    return Curry._1(param$1, Curry._1(mapSuccess, ok));
                  }));
    });
}

function fold(mapFail, mapSuccess, task) {
  return (function (_, param) {
      return Curry._2(task, (function (err) {
                    return Curry._1(param, Curry._1(mapFail, err));
                  }), (function (ok) {
                    return Curry._1(param, Curry._1(mapSuccess, ok));
                  }));
    });
}

function fromLazyPromise(f) {
  return (function (param, param$1) {
      Curry._1(f, /* () */0).then(param$1, param);
      return /* () */0;
    });
}

function fromOption(err, opt) {
  if (opt) {
    var a = opt[0];
    return (function (_, param) {
        return Curry._1(param, a);
      });
  } else {
    return (function (param, _) {
        return Curry._1(param, err);
      });
  }
}

function fromResult(res) {
  if (res.tag) {
    var a = res[0];
    return (function (_, param) {
        return Curry._1(param, a);
      });
  } else {
    var x = res[0];
    return (function (param, _) {
        return Curry._1(param, x);
      });
  }
}

function decodeJSON(decoder, json) {
  try {
    return /* Ok */Block.__(1, [Curry._1(decoder, json)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Json_decode.DecodeError) {
      return /* Error */Block.__(0, [exn[1]]);
    } else {
      throw exn;
    }
  }
}

function parseJSON(jsonString) {
  try {
    return /* Ok */Block.__(1, [JSON.parse(jsonString)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Js_exn.$$Error) {
      return /* Error */Block.__(0, [Option.withDefault("Could not parse JSON", Js_primitive.undefined_to_opt(exn[1].message))]);
    } else {
      throw exn;
    }
  }
}

var Remote$1 = [
  Remote.ready,
  Remote.error,
  Remote.pending,
  Remote.notAsked,
  Remote.map,
  Remote.map2,
  Remote.map3,
  Remote.flatten,
  Remote.flatMap,
  Remote.withDefault,
  Remote.fromResult,
  Remote.fromOption,
  Remote.isNotAsked,
  Remote.isPending,
  Remote.isFailed,
  Remote.isReady,
  Remote.encode
];

var List$1 = [
  List.length,
  isEmpty,
  reverse,
  List.merge,
  repeat,
  range,
  cons,
  append,
  flatten,
  zip,
  head,
  tail,
  nth,
  take,
  takeLast,
  takeWhile,
  takeUntil,
  drop,
  dropLast,
  dropWhile,
  dropUntil,
  filter,
  map,
  mapIndexed,
  map2,
  flatMap,
  flatMap2,
  filterMap,
  iter,
  iter2,
  iterIndexed,
  foldLeft,
  foldRight,
  foldLeft2,
  foldRight2,
  find,
  all,
  any,
  contains,
  partition,
  split,
  List.sort,
  Json_encode.list,
  Json_decode.list
];

var $$String$1 = [
  length,
  isEmpty$1,
  fromChar,
  Pervasives.string_of_int,
  Pervasives.string_of_float,
  fromChars,
  $$String.escaped,
  reverse$1,
  $$String.uppercase,
  $$String.lowercase,
  $$String.capitalize,
  $$String.uncapitalize,
  get$1,
  substring,
  $$String.trim,
  take$1,
  drop$1,
  takeLast$1,
  dropLast$1,
  takeUntil$1,
  takeWhile$1,
  dropUntil$1,
  dropWhile$1,
  split$1,
  words,
  lines,
  cons$1,
  uncons,
  append$1,
  $$String.concat,
  pad,
  leftPad,
  rightPad,
  $$String.iter,
  $$String.iteri,
  $$String.map,
  $$String.mapi,
  indexOf,
  lastIndexOf,
  indexFrom,
  lastIndexFrom,
  contains$2,
  encode$1,
  Json_decode.string
];

var Task = [
  make,
  succeed,
  fail,
  map$2,
  map2$1,
  map3,
  biMap,
  flatMap$1,
  fold,
  fromResult,
  fromOption,
  fork,
  fromLazyPromise
];

exports.identity     = identity;
exports.always       = always;
exports.$$void       = $$void;
exports.$great$great = $great$great;
exports.flip         = flip;
exports.curry        = curry;
exports.uncurry      = uncurry;
exports.tap          = tap;
exports.Remote       = Remote$1;
exports.Result       = Result$1;
exports.List         = List$1;
exports.Dict         = Dict;
exports.$$String     = $$String$1;
exports.Task         = Task;
exports.Option       = Option$1;
exports.decodeJSON   = decodeJSON;
exports.parseJSON    = parseJSON;
/* Js_dict Not a pure module */
