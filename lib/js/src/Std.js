// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var List                    = require("bs-platform/lib/js/list.js");
var $$Array                 = require("bs-platform/lib/js/array.js");
var Block                   = require("bs-platform/lib/js/block.js");
var Curry                   = require("bs-platform/lib/js/curry.js");
var Js_exn                  = require("bs-platform/lib/js/js_exn.js");
var $$String                = require("bs-platform/lib/js/string.js");
var Js_dict                 = require("bs-platform/lib/js/js_dict.js");
var Caml_obj                = require("bs-platform/lib/js/caml_obj.js");
var Pervasives              = require("bs-platform/lib/js/pervasives.js");
var Caml_string             = require("bs-platform/lib/js/caml_string.js");
var Json_decode             = require("bs-json/lib/js/src/Json_decode.js");
var Json_encode             = require("bs-json/lib/js/src/Json_encode.js");
var Caml_builtin_exceptions = require("bs-platform/lib/js/caml_builtin_exceptions.js");

function identity(a) {
  return a;
}

function always(a, _) {
  return a;
}

function $$void() {
  return /* () */0;
}

function $great$great(f, g, x) {
  return Curry._1(g, Curry._1(f, x));
}

function flip(f, a, b) {
  return Curry._2(f, b, a);
}

function curry(f, a, b) {
  return Curry._1(f, /* tuple */[
              a,
              b
            ]);
}

function uncurry(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function tap(f, a) {
  Curry._1(f, a);
  return a;
}

function decodeJSON(decoder, json) {
  try {
    return /* Ok */Block.__(0, [Curry._1(decoder, json)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Json_decode.DecodeError) {
      return /* Error */Block.__(1, [exn[1]]);
    } else {
      throw exn;
    }
  }
}

function parseJSON(jsonString) {
  try {
    return /* Ok */Block.__(0, [JSON.parse(jsonString)]);
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Js_exn.$$Error) {
      var match = exn[1].message;
      if (match !== undefined) {
        return /* Error */Block.__(1, [match]);
      } else {
        return /* Error */Block.__(1, ["Could not parse JSON"]);
      }
    } else {
      throw exn;
    }
  }
}

function some(a) {
  return /* Some */[a];
}

function map(f, opt) {
  if (opt) {
    return /* Some */[Curry._1(f, opt[0])];
  } else {
    return /* None */0;
  }
}

function map2(f, opt1, opt2) {
  if (opt1 && opt2) {
    return /* Some */[Curry._2(f, opt1[0], opt2[0])];
  } else {
    return /* None */0;
  }
}

function map3(f, opt1, opt2, opt3) {
  if (opt1 && opt2 && opt3) {
    return /* Some */[Curry._3(f, opt1[0], opt2[0], opt3[0])];
  } else {
    return /* None */0;
  }
}

function flatten(opt) {
  if (opt) {
    return opt[0];
  } else {
    return /* None */0;
  }
}

function flatMap(f, opt) {
  if (opt) {
    return Curry._1(f, opt[0]);
  } else {
    return /* None */0;
  }
}

function withDefault(defaultValue, opt) {
  if (opt) {
    return opt[0];
  } else {
    return defaultValue;
  }
}

function fromResult(res) {
  if (res.tag) {
    return /* None */0;
  } else {
    return /* Some */[res[0]];
  }
}

function fromRemote(res) {
  if (typeof res === "number" || res.tag !== 1) {
    return /* None */0;
  } else {
    return /* Some */[res[0]];
  }
}

function isNone(param) {
  if (param) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function isSome(param) {
  if (param) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function encode(encoder, param) {
  if (param) {
    return Curry._1(encoder, param[0]);
  } else {
    return null;
  }
}

var Option = /* module */[
  /* some */some,
  /* none : None */0,
  /* map */map,
  /* map2 */map2,
  /* map3 */map3,
  /* flatten */flatten,
  /* flatMap */flatMap,
  /* withDefault */withDefault,
  /* fromResult */fromResult,
  /* fromRemote */fromRemote,
  /* isNone */isNone,
  /* isSome */isSome,
  /* encode */encode,
  /* decode */Json_decode.optional
];

function reverse(xs) {
  var _acc = /* [] */0;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var acc = _acc;
    if (xs$1) {
      _xs = xs$1[1];
      _acc = /* :: */[
        xs$1[0],
        acc
      ];
      continue ;
      
    } else {
      return acc;
    }
  };
}

function isEmpty(xs) {
  if (xs) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function foldLeft(f, _acc, _xs) {
  while(true) {
    var xs = _xs;
    var acc = _acc;
    if (xs) {
      _xs = xs[1];
      _acc = Curry._2(f, xs[0], acc);
      continue ;
      
    } else {
      return acc;
    }
  };
}

function foldRight(f, acc, xs) {
  if (xs) {
    return Curry._2(f, xs[0], foldRight(f, acc, xs[1]));
  } else {
    return acc;
  }
}

function foldLeft2(f, _acc, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var acc = _acc;
    if (xs) {
      if (ys) {
        _ys = ys[1];
        _xs = xs[1];
        _acc = Curry._3(f, xs[0], ys[0], acc);
        continue ;
        
      } else {
        return acc;
      }
    } else {
      return acc;
    }
  };
}

function foldRight2(f, acc, xs, ys) {
  if (xs && ys) {
    return Curry._3(f, xs[0], ys[0], foldRight2(f, acc, xs[1], ys[1]));
  } else {
    return acc;
  }
}

function repeat(count, x) {
  var _acc = /* [] */0;
  var _count = count;
  while(true) {
    var count$1 = _count;
    var acc = _acc;
    if (count$1 <= 0) {
      return acc;
    } else {
      _count = count$1 - 1 | 0;
      _acc = /* :: */[
        x,
        acc
      ];
      continue ;
      
    }
  };
}

function range(start, stop) {
  var go = function (acc, start) {
    if (start >= stop) {
      return acc;
    } else {
      return /* :: */[
              start,
              go(acc, start + 1 | 0)
            ];
    }
  };
  return go(/* [] */0, start);
}

function cons(x, xs) {
  return Pervasives.$at(xs, /* :: */[
              x,
              /* [] */0
            ]);
}

var append = Pervasives.$at;

function flatten$1(xs) {
  return foldLeft(append, /* [] */0, xs);
}

function zip(xs, ys) {
  if (xs && ys) {
    return /* :: */[
            /* tuple */[
              xs[0],
              ys[0]
            ],
            zip(xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function head(xs) {
  if (xs) {
    return /* Some */[xs[0]];
  } else {
    return /* None */0;
  }
}

function tail(xs) {
  if (xs) {
    return xs[1];
  } else {
    return /* [] */0;
  }
}

function nth(_i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (xs) {
      if (i <= 0) {
        return /* Some */[xs[0]];
      } else {
        _xs = xs[1];
        _i = i - 1 | 0;
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function take(count, xs) {
  if (xs && count > 0) {
    return /* :: */[
            xs[0],
            take(count - 1 | 0, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function drop(_count, _xs) {
  while(true) {
    var xs = _xs;
    var count = _count;
    if (xs) {
      if (count <= 0) {
        return /* [] */0;
      } else {
        _xs = xs[1];
        _count = count - 1 | 0;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function takeLast(count, xs) {
  return drop(List.length(xs) - count | 0, xs);
}

function takeUntil(f, xs) {
  var _acc = /* [] */0;
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var acc = _acc;
    if (xs$1) {
      var x = xs$1[0];
      if (Curry._1(f$1, x)) {
        return acc;
      } else {
        _xs = xs$1[1];
        _acc = /* :: */[
          x,
          acc
        ];
        continue ;
        
      }
    } else {
      return acc;
    }
  };
}

function takeWhile(f, xs) {
  return takeUntil((function (a) {
                return 1 - Curry._1(f, a);
              }), xs);
}

function dropLast(count, xs) {
  return take(List.length(xs) - count | 0, xs);
}

function dropUntil(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      if (Curry._1(f, xs[0])) {
        return xs;
      } else {
        _xs = xs[1];
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function dropWhile(f, xs) {
  return dropUntil((function (x) {
                return 1 - Curry._1(f, x);
              }), xs);
}

function filter(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var xs$1 = xs[1];
      var x = xs[0];
      if (Curry._1(f, x)) {
        return /* :: */[
                x,
                filter(f, xs$1)
              ];
      } else {
        _xs = xs$1;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function map$1(f, xs) {
  if (xs) {
    return /* :: */[
            Curry._1(f, xs[0]),
            map$1(f, xs[1])
          ];
  } else {
    return /* [] */0;
  }
}

function mapIndexed(f, xs) {
  var go = function (i, f, xs) {
    if (xs) {
      return /* :: */[
              Curry._2(f, i, xs[0]),
              go(i + 1 | 0, f, xs[1])
            ];
    } else {
      return /* [] */0;
    }
  };
  return go(0, f, xs);
}

function map2$1(f, xs, ys) {
  if (xs && ys) {
    return /* :: */[
            Curry._2(f, xs[0], ys[0]),
            map2$1(f, xs[1], ys[1])
          ];
  } else {
    return /* [] */0;
  }
}

function flatMap$1(f, xs) {
  if (xs) {
    return Pervasives.$at(Curry._1(f, xs[0]), flatMap$1(f, xs[1]));
  } else {
    return /* [] */0;
  }
}

function flatMap2(f, xs, ys) {
  if (xs && ys) {
    return Pervasives.$at(Curry._2(f, xs[0], ys[0]), flatMap2(f, xs[1], ys[1]));
  } else {
    return /* [] */0;
  }
}

function filterMap(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var xs$1 = xs[1];
      var match = Curry._1(f, xs[0]);
      if (match) {
        return /* :: */[
                match[0],
                filterMap(f, xs$1)
              ];
      } else {
        _xs = xs$1;
        continue ;
        
      }
    } else {
      return /* [] */0;
    }
  };
}

function iter(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      Curry._1(f, xs[0]);
      _xs = xs[1];
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function iter2(f, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    if (xs) {
      if (ys) {
        Curry._2(f, xs[0], ys[0]);
        _ys = ys[1];
        _xs = xs[1];
        continue ;
        
      } else {
        return /* () */0;
      }
    } else {
      return /* () */0;
    }
  };
}

function iterIndexed(f, xs) {
  var _i = 0;
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var xs$1 = _xs;
    var i = _i;
    if (xs$1) {
      Curry._2(f$1, i, xs$1[0]);
      _xs = xs$1[1];
      _i = i + 1 | 0;
      continue ;
      
    } else {
      return /* () */0;
    }
  };
}

function find(f, _xs) {
  while(true) {
    var xs = _xs;
    if (xs) {
      var x = xs[0];
      if (Curry._1(f, x)) {
        return /* Some */[x];
      } else {
        _xs = xs[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function any(f, xs) {
  return isSome(find(f, xs));
}

function all(f, xs) {
  return any((function (x) {
                return 1 - Curry._1(f, x);
              }), xs);
}

function contains(y, xs) {
  return any((function (x) {
                return Caml_obj.caml_equal(x, y);
              }), xs);
}

function partition(f, xs) {
  var _param = /* tuple */[
    /* [] */0,
    /* [] */0
  ];
  var f$1 = f;
  var _xs = xs;
  while(true) {
    var param = _param;
    var xs$1 = _xs;
    var l2 = param[1];
    var l1 = param[0];
    if (xs$1) {
      var xs$2 = xs$1[1];
      var x = xs$1[0];
      if (Curry._1(f$1, x)) {
        _xs = xs$2;
        _param = /* tuple */[
          /* :: */[
            x,
            l1
          ],
          l2
        ];
        continue ;
        
      } else {
        _xs = xs$2;
        _param = /* tuple */[
          l1,
          /* :: */[
            x,
            l2
          ]
        ];
        continue ;
        
      }
    } else {
      return /* tuple */[
              l1,
              l2
            ];
    }
  };
}

function split(pairs) {
  var _param = /* tuple */[
    /* [] */0,
    /* [] */0
  ];
  var _pairs = pairs;
  while(true) {
    var param = _param;
    var pairs$1 = _pairs;
    var ys = param[1];
    var xs = param[0];
    if (pairs$1) {
      var match = pairs$1[0];
      _pairs = pairs$1[1];
      _param = /* tuple */[
        /* :: */[
          match[0],
          xs
        ],
        /* :: */[
          match[1],
          ys
        ]
      ];
      continue ;
      
    } else {
      return /* tuple */[
              xs,
              ys
            ];
    }
  };
}

function fromList(a) {
  return a;
}

function get(key, _dict) {
  while(true) {
    var dict = _dict;
    if (dict) {
      var match = dict[0];
      if (Caml_obj.caml_equal(match[0], key)) {
        return /* Some */[match[1]];
      } else {
        _dict = dict[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function find$1(f, _dict) {
  while(true) {
    var dict = _dict;
    if (dict) {
      var v = dict[0][1];
      if (Curry._1(f, v)) {
        return /* Some */[v];
      } else {
        _dict = dict[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function contains$1(key, dict) {
  return isSome(get(key, dict));
}

function set(key, value, dict) {
  return /* :: */[
          /* tuple */[
            key,
            value
          ],
          filter((function (param) {
                  return Caml_obj.caml_notequal(param[0], key);
                }), dict)
        ];
}

function setDefault(key, value, dict) {
  if (contains$1(key, dict)) {
    return dict;
  } else {
    return /* :: */[
            /* tuple */[
              key,
              value
            ],
            dict
          ];
  }
}

function keys(dict) {
  return map$1((function (param) {
                return param[0];
              }), dict);
}

function values(dict) {
  return map$1((function (param) {
                return param[1];
              }), dict);
}

function iter$1(f) {
  return (function (param) {
      return iter((function (param) {
                    return uncurry(f, param);
                  }), param);
    });
}

function map$2(f, dict) {
  return map$1((function (param) {
                var k = param[0];
                return /* tuple */[
                        k,
                        Curry._2(f, k, param[1])
                      ];
              }), dict);
}

function mapValues(f, dict) {
  return map$1((function (param) {
                return /* tuple */[
                        param[0],
                        Curry._1(f, param[1])
                      ];
              }), dict);
}

function mapKeys(f, dict) {
  return map$1((function (param) {
                return /* tuple */[
                        Curry._1(f, param[0]),
                        param[1]
                      ];
              }), dict);
}

function filter$1(f) {
  return (function (param) {
      return filter((function (param) {
                    return uncurry(f, param);
                  }), param);
    });
}

function foldLeft$1(f, acc, dict) {
  return foldLeft((function (param, acc) {
                return Curry._3(f, param[0], param[1], acc);
              }), acc, dict);
}

function foldRight$1(f, acc, dict) {
  return foldRight((function (param, acc) {
                return Curry._3(f, param[0], param[1], acc);
              }), acc, dict);
}

function encode$1(encodeKey, encodeValue, dict) {
  return Json_encode.object_(mapValues(encodeValue, mapKeys(encodeKey, dict)));
}

function decode(decodeKey, decodeValue, json) {
  return mapKeys(decodeKey, $$Array.to_list(Js_dict.entries(Json_decode.dict(decodeValue, json))));
}

var Dict = /* module */[
  /* empty : [] */0,
  /* fromList */fromList,
  /* get */get,
  /* find */find$1,
  /* contains */contains$1,
  /* set */set,
  /* setDefault */setDefault,
  /* keys */keys,
  /* values */values,
  /* iter */iter$1,
  /* map */map$2,
  /* mapValues */mapValues,
  /* mapKeys */mapKeys,
  /* filter */filter$1,
  /* foldLeft */foldLeft$1,
  /* foldRight */foldRight$1,
  /* encode */encode$1,
  /* decode */decode
];

function ready(a) {
  return /* Ready */Block.__(1, [a]);
}

function error(x) {
  return /* Failed */Block.__(0, [x]);
}

function map$3(f, remote) {
  if (typeof remote === "number") {
    if (remote) {
      return /* Pending */1;
    } else {
      return /* NotAsked */0;
    }
  } else if (remote.tag) {
    return /* Ready */Block.__(1, [Curry._1(f, remote[0])]);
  } else {
    return /* Failed */Block.__(0, [remote[0]]);
  }
}

function map2$2(f, r1, r2) {
  if (typeof r1 === "number") {
    if (r1) {
      return /* Pending */1;
    } else {
      return /* NotAsked */0;
    }
  } else if (r1.tag) {
    if (typeof r2 === "number") {
      if (r2) {
        return /* Pending */1;
      } else {
        return /* NotAsked */0;
      }
    } else if (r2.tag) {
      return /* Ready */Block.__(1, [Curry._2(f, r1[0], r2[0])]);
    } else {
      return /* Failed */Block.__(0, [r2[0]]);
    }
  } else {
    return /* Failed */Block.__(0, [r1[0]]);
  }
}

function map3$1(f, r1, r2, r3) {
  if (typeof r1 === "number") {
    if (r1) {
      return /* Pending */1;
    } else {
      return /* NotAsked */0;
    }
  } else if (r1.tag) {
    if (typeof r2 === "number") {
      if (r2) {
        return /* Pending */1;
      } else {
        return /* NotAsked */0;
      }
    } else if (r2.tag) {
      if (typeof r3 === "number") {
        if (r3) {
          return /* Pending */1;
        } else {
          return /* NotAsked */0;
        }
      } else if (r3.tag) {
        return /* Ready */Block.__(1, [Curry._3(f, r1[0], r2[0], r3[0])]);
      } else {
        return /* Failed */Block.__(0, [r3[0]]);
      }
    } else {
      return /* Failed */Block.__(0, [r2[0]]);
    }
  } else {
    return /* Failed */Block.__(0, [r1[0]]);
  }
}

function flatten$2(r) {
  if (typeof r === "number") {
    if (r) {
      return /* Pending */1;
    } else {
      return /* NotAsked */0;
    }
  } else if (r.tag) {
    return r[0];
  } else {
    return /* Failed */Block.__(0, [r[0]]);
  }
}

function flatMap$2(f, remote) {
  if (typeof remote === "number") {
    if (remote) {
      return /* Pending */1;
    } else {
      return /* NotAsked */0;
    }
  } else if (remote.tag) {
    return Curry._1(f, remote[0]);
  } else {
    return /* Failed */Block.__(0, [remote[0]]);
  }
}

function withDefault$1(a, rem) {
  if (typeof rem === "number" || rem.tag !== 1) {
    return a;
  } else {
    return rem[0];
  }
}

function fromResult$1(res) {
  if (res.tag) {
    return /* Failed */Block.__(0, [res[0]]);
  } else {
    return /* Ready */Block.__(1, [res[0]]);
  }
}

function fromOption(opt) {
  if (opt) {
    return /* Ready */Block.__(1, [opt[0]]);
  } else {
    return /* NotAsked */0;
  }
}

function isNotAsked(remote) {
  if (typeof remote === "number" && remote === 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isPending(remote) {
  if (typeof remote === "number" && remote !== 0) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isFailed(remote) {
  if (typeof remote === "number" || remote.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function isReady(remote) {
  if (typeof remote === "number" || remote.tag !== 1) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function encode$2(successEncoder, failEncoder, r) {
  if (typeof r === "number") {
    if (r) {
      return "Pending";
    } else {
      return "NotAsked";
    }
  } else if (r.tag) {
    return Curry._1(successEncoder, r[0]);
  } else {
    return Curry._1(failEncoder, r[0]);
  }
}

function map$4(f, res) {
  if (res.tag) {
    return /* Error */Block.__(1, [res[0]]);
  } else {
    return /* Ok */Block.__(0, [Curry._1(f, res[0])]);
  }
}

function map2$3(f, r1, r2) {
  if (r1.tag) {
    return /* Error */Block.__(1, [r1[0]]);
  } else if (r2.tag) {
    return /* Error */Block.__(1, [r2[0]]);
  } else {
    return /* Ok */Block.__(0, [Curry._2(f, r1[0], r2[0])]);
  }
}

function map3$2(f, r1, r2, r3) {
  if (r1.tag) {
    return /* Error */Block.__(1, [r1[0]]);
  } else if (r2.tag) {
    return /* Error */Block.__(1, [r2[0]]);
  } else if (r3.tag) {
    return /* Error */Block.__(1, [r3[0]]);
  } else {
    return /* Ok */Block.__(0, [Curry._3(f, r1[0], r2[0], r3[0])]);
  }
}

function flatten$3(r) {
  if (r.tag) {
    return /* Error */Block.__(1, [r[0]]);
  } else {
    return r[0];
  }
}

function flatMap$3(f, res) {
  if (res.tag) {
    return /* Error */Block.__(1, [res[0]]);
  } else {
    return Curry._1(f, res[0]);
  }
}

function withDefault$2(a, res) {
  if (res.tag) {
    return a;
  } else {
    return res[0];
  }
}

function fromOption$1(err, opt) {
  if (opt) {
    return /* Ok */Block.__(0, [opt[0]]);
  } else {
    return /* Error */Block.__(1, [err]);
  }
}

function isError(res) {
  if (res.tag) {
    return /* true */1;
  } else {
    return /* false */0;
  }
}

function isOk(res) {
  if (res.tag) {
    return /* false */0;
  } else {
    return /* true */1;
  }
}

function encode$3(encodeError, encodeOk, param) {
  if (param.tag) {
    return Curry._1(encodeError, param[0]);
  } else {
    return Curry._1(encodeOk, param[0]);
  }
}

var Result = /* module */[
  /* map */map$4,
  /* map2 */map2$3,
  /* map3 */map3$2,
  /* flatten */flatten$3,
  /* flatMap */flatMap$3,
  /* withDefault */withDefault$2,
  /* fromOption */fromOption$1,
  /* isError */isError,
  /* isOk */isOk,
  /* encode */encode$3
];

function length(prim) {
  return prim.length;
}

function isEmpty$1(s) {
  return +(s === "");
}

function fromChar(param) {
  return $$String.make(1, param);
}

function fromChars(chars) {
  return foldLeft((function (ch, str) {
                return str + $$String.make(1, ch);
              }), "", chars);
}

function get$1(index, str) {
  try {
    return /* Some */[Caml_string.get(str, index)];
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function cons$1(ch, str) {
  return $$String.make(1, ch) + str;
}

function substring(start, len, str) {
  try {
    return $$String.sub(str, start, Pervasives.min(len, str.length - start | 0));
  }
  catch (raw_exn){
    var exn = Js_exn.internalToOCamlException(raw_exn);
    if (exn[0] === Caml_builtin_exceptions.invalid_argument) {
      return "";
    } else {
      throw exn;
    }
  }
}

function uncons(str) {
  var match = get$1(0, str);
  if (match) {
    return /* Some */[/* tuple */[
              match[0],
              substring(1, str.length, str)
            ]];
  } else {
    return /* None */0;
  }
}

function take$1(i, str) {
  return substring(0, i, str);
}

function drop$1(i, str) {
  return substring(i, str.length, str);
}

function takeLast$1(i, str) {
  return drop$1(str.length - i | 0, str);
}

function dropLast$1(i, str) {
  return substring(0, str.length - i | 0, str);
}

function takeUntil$1(f, str) {
  var match = uncons(str);
  if (match) {
    var match$1 = match[0];
    var ch = match$1[0];
    if (Curry._1(f, ch)) {
      return "";
    } else {
      return $$String.make(1, ch) + takeUntil$1(f, match$1[1]);
    }
  } else {
    return "";
  }
}

function takeWhile$1(f, str) {
  return takeUntil$1((function (x) {
                return 1 - Curry._1(f, x);
              }), str);
}

function dropUntil$1(f, _str) {
  while(true) {
    var str = _str;
    var match = uncons(str);
    if (match) {
      var match$1 = match[0];
      var str$1 = match$1[1];
      if (Curry._1(f, match$1[0])) {
        return str$1;
      } else {
        _str = str$1;
        continue ;
        
      }
    } else {
      return "";
    }
  };
}

function dropWhile$1(f, str) {
  return dropUntil$1((function (x) {
                return 1 - Curry._1(f, x);
              }), str);
}

function reverse$1(s) {
  var match = uncons(s);
  if (match) {
    var match$1 = match[0];
    return reverse$1(match$1[1]) + $$String.make(1, match$1[0]);
  } else {
    return "";
  }
}

function append$1(x, y) {
  return x + y;
}

function indexOf(ch, str) {
  try {
    return /* Some */[$$String.index(str, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function lastIndexOf(ch, str) {
  try {
    return /* Some */[$$String.rindex(str, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function indexFrom(i, ch, str) {
  try {
    return /* Some */[$$String.index_from(str, i, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function lastIndexFrom(i, ch, str) {
  try {
    return /* Some */[$$String.rindex_from(str, i, ch)];
  }
  catch (exn){
    if (exn === Caml_builtin_exceptions.not_found) {
      return /* None */0;
    } else {
      throw exn;
    }
  }
}

function contains$2(c, s) {
  return $$String.contains(s, c);
}

function pad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = padding + (str + padding);
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function leftPad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = padding + str;
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function rightPad(_i, _padding, str) {
  while(true) {
    var padding = _padding;
    var i = _i;
    if (i <= 0) {
      return str;
    } else {
      _padding = str + padding;
      _i = i - 1 | 0;
      continue ;
      
    }
  };
}

function split$1(separator, str) {
  var len = separator.length;
  var go = function (_i, str) {
    while(true) {
      var i = _i;
      var sub = substring(i, len, str);
      if (sub === separator) {
        return /* :: */[
                substring(0, i, str),
                go(0, drop$1(i + len | 0, str))
              ];
      } else if (i === str.length) {
        return /* :: */[
                str,
                /* [] */0
              ];
      } else {
        _i = i + 1 | 0;
        continue ;
        
      }
    };
  };
  return go(0, str);
}

function lines(param) {
  return split$1("\n", param);
}

function words(param) {
  return split$1(" ", param);
}

function encode$4(prim) {
  return prim;
}

var List$1 = [
  List.length,
  isEmpty,
  reverse,
  List.merge,
  repeat,
  range,
  cons,
  append,
  flatten$1,
  zip,
  head,
  tail,
  nth,
  take,
  takeLast,
  takeWhile,
  takeUntil,
  drop,
  dropLast,
  dropWhile,
  dropUntil,
  filter,
  map$1,
  mapIndexed,
  map2$1,
  flatMap$1,
  flatMap2,
  filterMap,
  iter,
  iter2,
  iterIndexed,
  foldLeft,
  foldRight,
  foldLeft2,
  foldRight2,
  find,
  all,
  any,
  contains,
  partition,
  split,
  List.sort,
  Json_encode.list,
  Json_decode.list
];

var Remote = [
  ready,
  error,
  /* Pending */1,
  /* NotAsked */0,
  map$3,
  map2$2,
  map3$1,
  flatten$2,
  flatMap$2,
  withDefault$1,
  fromResult$1,
  fromOption,
  isNotAsked,
  isPending,
  isFailed,
  isReady,
  encode$2
];

var $$String$1 = [
  length,
  isEmpty$1,
  fromChar,
  Pervasives.string_of_int,
  Pervasives.string_of_float,
  fromChars,
  $$String.escaped,
  reverse$1,
  $$String.uppercase,
  $$String.lowercase,
  $$String.capitalize,
  $$String.uncapitalize,
  get$1,
  substring,
  $$String.trim,
  take$1,
  drop$1,
  takeLast$1,
  dropLast$1,
  takeUntil$1,
  takeWhile$1,
  dropUntil$1,
  dropWhile$1,
  split$1,
  words,
  lines,
  cons$1,
  uncons,
  append$1,
  $$String.concat,
  pad,
  leftPad,
  rightPad,
  $$String.iter,
  $$String.iteri,
  $$String.map,
  $$String.mapi,
  indexOf,
  lastIndexOf,
  indexFrom,
  lastIndexFrom,
  contains$2,
  encode$4,
  Json_decode.string
];

exports.identity     = identity;
exports.always       = always;
exports.$$void       = $$void;
exports.$great$great = $great$great;
exports.flip         = flip;
exports.curry        = curry;
exports.uncurry      = uncurry;
exports.tap          = tap;
exports.decodeJSON   = decodeJSON;
exports.parseJSON    = parseJSON;
exports.Option       = Option;
exports.List         = List$1;
exports.Dict         = Dict;
exports.Remote       = Remote;
exports.Result       = Result;
exports.$$String     = $$String$1;
/* Js_dict Not a pure module */
