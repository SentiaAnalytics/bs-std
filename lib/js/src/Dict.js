// Generated by BUCKLESCRIPT VERSION 2.0.0, PLEASE EDIT WITH CARE
'use strict';

var $$Array     = require("bs-platform/lib/js/array.js");
var Curry       = require("bs-platform/lib/js/curry.js");
var Option      = require("./Option.js");
var Js_dict     = require("bs-platform/lib/js/js_dict.js");
var Prelude     = require("./Prelude.js");
var StdList     = require("./StdList.js");
var Caml_obj    = require("bs-platform/lib/js/caml_obj.js");
var Json_decode = require("bs-json/lib/js/src/Json_decode.js");
var Json_encode = require("bs-json/lib/js/src/Json_encode.js");

function fromList(a) {
  return a;
}

function get(key, _dict) {
  while(true) {
    var dict = _dict;
    if (dict) {
      var match = dict[0];
      if (Caml_obj.caml_equal(match[0], key)) {
        return /* Some */[match[1]];
      } else {
        _dict = dict[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function find(f, _dict) {
  while(true) {
    var dict = _dict;
    if (dict) {
      var v = dict[0][1];
      if (Curry._1(f, v)) {
        return /* Some */[v];
      } else {
        _dict = dict[1];
        continue ;
        
      }
    } else {
      return /* None */0;
    }
  };
}

function contains(key, dict) {
  return Option.isSome(get(key, dict));
}

function set(key, value, dict) {
  return /* :: */[
          /* tuple */[
            key,
            value
          ],
          StdList.filter((function (param) {
                  return Caml_obj.caml_notequal(param[0], key);
                }), dict)
        ];
}

function setDefault(key, value, dict) {
  if (Option.isSome(get(key, dict))) {
    return dict;
  } else {
    return /* :: */[
            /* tuple */[
              key,
              value
            ],
            dict
          ];
  }
}

function keys(dict) {
  return StdList.map((function (param) {
                return param[0];
              }), dict);
}

function values(dict) {
  return StdList.map((function (param) {
                return param[1];
              }), dict);
}

function iter(f) {
  return (function (param) {
      return StdList.iter((function (param) {
                    return Prelude.uncurry(f, param);
                  }), param);
    });
}

function map(f, dict) {
  return StdList.map((function (param) {
                var k = param[0];
                return /* tuple */[
                        k,
                        Curry._2(f, k, param[1])
                      ];
              }), dict);
}

function mapValues(f, dict) {
  return StdList.map((function (param) {
                return /* tuple */[
                        param[0],
                        Curry._1(f, param[1])
                      ];
              }), dict);
}

function mapKeys(f, dict) {
  return StdList.map((function (param) {
                return /* tuple */[
                        Curry._1(f, param[0]),
                        param[1]
                      ];
              }), dict);
}

function filter(f) {
  return (function (param) {
      return StdList.filter((function (param) {
                    return Prelude.uncurry(f, param);
                  }), param);
    });
}

function foldLeft(f, acc, dict) {
  return StdList.foldLeft((function (param, acc) {
                return Curry._3(f, param[0], param[1], acc);
              }), acc, dict);
}

function foldRight(f, acc, dict) {
  return StdList.foldRight((function (param, acc) {
                return Curry._3(f, param[0], param[1], acc);
              }), acc, dict);
}

function encode(encodeKey, encodeValue, dict) {
  return Json_encode.object_(mapValues(encodeValue, mapKeys(encodeKey, dict)));
}

function decode(decodeKey, decodeValue, json) {
  return mapKeys(decodeKey, $$Array.to_list(Js_dict.entries(Json_decode.dict(decodeValue, json))));
}

var empty = /* [] */0;

exports.empty      = empty;
exports.fromList   = fromList;
exports.get        = get;
exports.find       = find;
exports.contains   = contains;
exports.set        = set;
exports.setDefault = setDefault;
exports.keys       = keys;
exports.values     = values;
exports.iter       = iter;
exports.map        = map;
exports.mapValues  = mapValues;
exports.mapKeys    = mapKeys;
exports.filter     = filter;
exports.foldLeft   = foldLeft;
exports.foldRight  = foldRight;
exports.encode     = encode;
exports.decode     = decode;
/* Js_dict Not a pure module */
